// Code generated by sqlc-like tooling. DO NOT EDIT.
package sqlc

import (
	"context"
	"errors"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// DBTX matches pgxpool.Pool and pgx.Conn interfaces.
type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

// Queries wraps prepared statements used by repositories.
type Queries struct {
	db DBTX
}

// New instantiates Queries.
func New(db DBTX) *Queries {
	return &Queries{db: db}
}

// Domain rows.
type GetDomainByHostRow struct {
	ID       int64
	Host     string
	TenantID int64
}

const getDomainByHostSQL = `SELECT id, host, tenant_id FROM domains WHERE host = $1 LIMIT 1`

func (q *Queries) GetDomainByHost(ctx context.Context, host string) (GetDomainByHostRow, error) {
	row := q.db.QueryRow(ctx, getDomainByHostSQL, host)
	var res GetDomainByHostRow
	err := row.Scan(&res.ID, &res.Host, &res.TenantID)
	return res, err
}

// Tenant row.
type GetTenantRow struct {
	ID          int64
	Type        string
	Name        string
	Code        string
	Slug        string
	CountryCode string
	Timezone    string
	IsDefault   bool
	Status      string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

const getTenantSQL = `SELECT id, type, name, code, slug, country_code, timezone, is_default, status, created_at, updated_at FROM tenants WHERE id = $1 LIMIT 1`

func (q *Queries) GetTenant(ctx context.Context, tenantID int64) (GetTenantRow, error) {
	row := q.db.QueryRow(ctx, getTenantSQL, tenantID)
	var res GetTenantRow
	err := row.Scan(
		&res.ID,
		&res.Type,
		&res.Name,
		&res.Code,
		&res.Slug,
		&res.CountryCode,
		&res.Timezone,
		&res.IsDefault,
		&res.Status,
		&res.CreatedAt,
		&res.UpdatedAt,
	)
	return res, err
}

// Branding row.
type GetBrandingRow struct {
	TenantID     int64
	LogoURL      string
	PrimaryColor string
}

const getBrandingSQL = `SELECT tenant_id, COALESCE(logo_url, '') AS logo_url, COALESCE(primary_color, '') AS primary_color FROM brandings WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetBranding(ctx context.Context, tenantID int64) (GetBrandingRow, error) {
	row := q.db.QueryRow(ctx, getBrandingSQL, tenantID)
	var res GetBrandingRow
	err := row.Scan(&res.TenantID, &res.LogoURL, &res.PrimaryColor)
	return res, err
}

// Auth provider rows.
type ListAuthProvidersRow struct {
	TenantID int64
	Type     string
	Name     string
	Enabled  bool
}

const listAuthProvidersSQL = `SELECT tenant_id, provider_type AS type, provider_type AS name, is_active AS enabled FROM tenant_auth_providers WHERE tenant_id = $1`

func (q *Queries) ListAuthProviders(ctx context.Context, tenantID int64) ([]ListAuthProvidersRow, error) {
	rows, err := q.db.Query(ctx, listAuthProvidersSQL, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var res []ListAuthProvidersRow
	for rows.Next() {
		var r ListAuthProvidersRow
		if err := rows.Scan(&r.TenantID, &r.Type, &r.Name, &r.Enabled); err != nil {
			return nil, err
		}
		res = append(res, r)
	}
	return res, rows.Err()
}

// Password config row.
type GetPasswordConfigRow struct {
	TenantID        int64
	Enabled         bool
	MaxAttempts     int32
	LockoutInterval time.Duration
}

const getPasswordConfigSQL = `SELECT tenant_id, enabled, max_attempts, lockout_interval FROM password_configs WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetPasswordConfig(ctx context.Context, tenantID int64) (GetPasswordConfigRow, error) {
	row := q.db.QueryRow(ctx, getPasswordConfigSQL, tenantID)
	var res GetPasswordConfigRow
	err := row.Scan(&res.TenantID, &res.Enabled, &res.MaxAttempts, &res.LockoutInterval)
	return res, err
}

// OTP config row.
type GetOTPConfigRow struct {
	TenantID int64
	Enabled  bool
	Length   int32
	TTL      time.Duration
}

const getOTPConfigSQL = `SELECT tenant_id, enabled, length, ttl FROM otp_configs WHERE tenant_id = $1 LIMIT 1`

func (q *Queries) GetOTPConfig(ctx context.Context, tenantID int64) (GetOTPConfigRow, error) {
	row := q.db.QueryRow(ctx, getOTPConfigSQL, tenantID)
	var res GetOTPConfigRow
	err := row.Scan(&res.TenantID, &res.Enabled, &res.Length, &res.TTL)
	return res, err
}

// OAuth IDP config rows.
type ListOAuthIDPConfigsRow struct {
	TenantID         int64
	Provider         string
	ClientID         string
	ClientSecret     string
	RedirectURI      string
	Enabled          bool
	Scopes           []string
	DisplayName      string
	AuthorizationURL string
}

const listOAuthIDPConfigsSQL = `SELECT tenant_id, provider, client_id, client_secret, redirect_uri, enabled, scopes, display_name, authorization_url FROM oauth_idp_configs WHERE tenant_id = $1`

func (q *Queries) ListOAuthIDPConfigs(ctx context.Context, tenantID int64) ([]ListOAuthIDPConfigsRow, error) {
	rows, err := q.db.Query(ctx, listOAuthIDPConfigsSQL, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var res []ListOAuthIDPConfigsRow
	for rows.Next() {
		var r ListOAuthIDPConfigsRow
		var scopes string
		if err := rows.Scan(&r.TenantID, &r.Provider, &r.ClientID, &r.ClientSecret, &r.RedirectURI, &r.Enabled, &scopes, &r.DisplayName, &r.AuthorizationURL); err != nil {
			return nil, err
		}
		if scopes != "" {
			r.Scopes = strings.Split(scopes, ",")
		}
		res = append(res, r)
	}
	return res, rows.Err()
}

// User row.
type GetUserByEmailRow struct {
	ID             int64
	TenantID       int64
	Email          string
	PasswordHash   string
	Name           string
	PictureURL     string
	Blocked        bool
	FailedAttempts int32
	LockedUntil    time.Time
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

const getUserByEmailSQL = `SELECT id, tenant_id, email, password_hash, name, picture_url, blocked, failed_attempts, locked_until, created_at, updated_at FROM users WHERE tenant_id = $1 AND email = $2 LIMIT 1`

func (q *Queries) GetUserByEmail(ctx context.Context, tenantID int64, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmailSQL, tenantID, email)
	var res GetUserByEmailRow
	err := row.Scan(&res.ID, &res.TenantID, &res.Email, &res.PasswordHash, &res.Name, &res.PictureURL, &res.Blocked, &res.FailedAttempts, &res.LockedUntil, &res.CreatedAt, &res.UpdatedAt)
	return res, err
}

const getUserByIDSQL = `SELECT id, tenant_id, email, password_hash, name, picture_url, blocked, failed_attempts, locked_until, created_at, updated_at FROM users WHERE tenant_id = $1 AND id = $2 LIMIT 1`

func (q *Queries) GetUserByID(ctx context.Context, tenantID, userID int64) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByIDSQL, tenantID, userID)
	var res GetUserByEmailRow
	err := row.Scan(&res.ID, &res.TenantID, &res.Email, &res.PasswordHash, &res.Name, &res.PictureURL, &res.Blocked, &res.FailedAttempts, &res.LockedUntil, &res.CreatedAt, &res.UpdatedAt)
	return res, err
}

const updateUserLoginStatsSQL = `UPDATE users SET failed_attempts = $2, locked_until = $3, updated_at = NOW() WHERE id = $1`

func (q *Queries) UpdateUserLoginStats(ctx context.Context, id int64, failed int32, lockedUntil time.Time) error {
	_, err := q.db.Exec(ctx, updateUserLoginStatsSQL, id, failed, lockedUntil)
	return err
}

// OAuth token rows.
type InsertOAuthTokenRow struct {
	ID            int64
	TenantID      int64
	UserID        int64
	ClientID      string
	Scope         string
	RefreshToken  string
	AccessTokenID string
	CreatedAt     time.Time
	ExpiresAt     time.Time
	RotatedAt     time.Time
	Revoked       bool
}

const insertOAuthTokenSQL = `INSERT INTO oauth_tokens (tenant_id, user_id, client_id, scope, refresh_token, access_token_id, expires_at) VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING id, tenant_id, user_id, client_id, scope, refresh_token, access_token_id, created_at, expires_at, rotated_at, revoked`

func (q *Queries) InsertOAuthToken(ctx context.Context, tenantID, userID int64, clientID, scope, refreshToken, accessTokenID string, expiresAt time.Time) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, insertOAuthTokenSQL, tenantID, userID, clientID, scope, refreshToken, accessTokenID, expiresAt)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.UserID, &res.ClientID, &res.Scope, &res.RefreshToken, &res.AccessTokenID, &res.CreatedAt, &res.ExpiresAt, &res.RotatedAt, &res.Revoked)
	return res, err
}

const getOAuthTokenByRefreshSQL = `SELECT id, tenant_id, user_id, client_id, scope, refresh_token, access_token_id, created_at, expires_at, rotated_at, revoked FROM oauth_tokens WHERE tenant_id = $1 AND refresh_token = $2 LIMIT 1`

func (q *Queries) GetOAuthTokenByRefresh(ctx context.Context, tenantID int64, refreshToken string) (InsertOAuthTokenRow, error) {
	row := q.db.QueryRow(ctx, getOAuthTokenByRefreshSQL, tenantID, refreshToken)
	var res InsertOAuthTokenRow
	err := row.Scan(&res.ID, &res.TenantID, &res.UserID, &res.ClientID, &res.Scope, &res.RefreshToken, &res.AccessTokenID, &res.CreatedAt, &res.ExpiresAt, &res.RotatedAt, &res.Revoked)
	return res, err
}

const rotateRefreshTokenSQL = `UPDATE oauth_tokens SET refresh_token = $2, expires_at = $3, rotated_at = NOW() WHERE id = $1`

func (q *Queries) RotateRefreshToken(ctx context.Context, id int64, refreshToken string, expiresAt time.Time) error {
	_, err := q.db.Exec(ctx, rotateRefreshTokenSQL, id, refreshToken, expiresAt)
	return err
}

const revokeOAuthTokenSQL = `UPDATE oauth_tokens SET revoked = true WHERE id = $1`

func (q *Queries) RevokeOAuthToken(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, revokeOAuthTokenSQL, id)
	return err
}

// OAuth code rows.
type GetOAuthCodeRow struct {
	Code        string
	TenantID    int64
	UserID      int64
	ClientID    string
	RedirectURI string
	Scope       string
	ExpiresAt   time.Time
	Used        bool
}

const insertOAuthCodeSQL = `INSERT INTO oauth_codes (code, tenant_id, user_id, client_id, redirect_uri, scope, expires_at) VALUES ($1,$2,$3,$4,$5,$6,$7)`

func (q *Queries) InsertOAuthCode(ctx context.Context, code string, tenantID, userID int64, clientID, redirectURI, scope string, expiresAt time.Time) error {
	_, err := q.db.Exec(ctx, insertOAuthCodeSQL, code, tenantID, userID, clientID, redirectURI, scope, expiresAt)
	return err
}

const getOAuthCodeSQL = `SELECT code, tenant_id, user_id, client_id, redirect_uri, scope, expires_at, used FROM oauth_codes WHERE tenant_id = $1 AND code = $2 LIMIT 1`

func (q *Queries) GetOAuthCode(ctx context.Context, tenantID int64, code string) (GetOAuthCodeRow, error) {
	row := q.db.QueryRow(ctx, getOAuthCodeSQL, tenantID, code)
	var res GetOAuthCodeRow
	err := row.Scan(&res.Code, &res.TenantID, &res.UserID, &res.ClientID, &res.RedirectURI, &res.Scope, &res.ExpiresAt, &res.Used)
	return res, err
}

const markOAuthCodeUsedSQL = `UPDATE oauth_codes SET used = true WHERE code = $1`

func (q *Queries) MarkOAuthCodeUsed(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, markOAuthCodeUsedSQL, code)
	return err
}

// OAuth keys.
type GetActiveOAuthKeyRow struct {
	ID        int64
	TenantID  int64
	KID       string
	Secret    []byte
	Algorithm string
	Active    bool
	CreatedAt time.Time
}

const getActiveOAuthKeySQL = `SELECT id, tenant_id, kid, secret, algorithm, active, created_at FROM oauth_keys WHERE tenant_id = $1 AND active = true ORDER BY created_at DESC LIMIT 1`

func (q *Queries) GetActiveOAuthKey(ctx context.Context, tenantID int64) (GetActiveOAuthKeyRow, error) {
	row := q.db.QueryRow(ctx, getActiveOAuthKeySQL, tenantID)
	var res GetActiveOAuthKeyRow
	err := row.Scan(&res.ID, &res.TenantID, &res.KID, &res.Secret, &res.Algorithm, &res.Active, &res.CreatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return res, err
	}
	return res, err
}

const insertOAuthKeySQL = `INSERT INTO oauth_keys (tenant_id, kid, secret, algorithm, active) VALUES ($1,$2,$3,$4,true) RETURNING id, tenant_id, kid, secret, algorithm, active, created_at`

func (q *Queries) InsertOAuthKey(ctx context.Context, tenantID int64, kid string, secret []byte, algorithm string) (GetActiveOAuthKeyRow, error) {
	row := q.db.QueryRow(ctx, insertOAuthKeySQL, tenantID, kid, secret, algorithm)
	var res GetActiveOAuthKeyRow
	err := row.Scan(&res.ID, &res.TenantID, &res.KID, &res.Secret, &res.Algorithm, &res.Active, &res.CreatedAt)
	return res, err
}
